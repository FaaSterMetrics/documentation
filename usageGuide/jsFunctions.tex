\documentclass[../main.tex]{subfiles}
\begin{document}

\section{Writing Your Own JavaScript Functions}\label{sec:jsFunctions}

One of the main advantages of this framework is that you are able to write a function once 
and then deploy it to any supported platform without additional modification afterwards.
To this end, Node.js and its module semantics are used. A typical function may look like this:

\begin{tcolorbox}
\begin{minted}{js}
  const lib = require('@faastermetrics/lib')
  module.exports = lib.serverless.rpcHandler(async (event, ctx) => {
    return {result: 'Hello World'}
  })
\end{minted}
\end{tcolorbox}

As can be seen, our FaaSterMetrics library is used universally across the project. 
We~also wrote an asynchronous JavaScript function that returns a JavaScript object with a \mintinline{js}{'Hello World'} string. 
This function is passed to the so-called `rpcHandler' which then gets exported. 

\subsection{Function Naming Convention}

Each FaaS function of an experiment should be found in a file named index.js which has its own directory within the experiment's functions folder.
Thus, the path to the function code will somehow end as follows (see also -TODO:\@ redacted-):

\begin{tcolorbox}
  \texttt{[\ldots]/experiments/<experiment\_name>/functions/<function\_name>/index.js}
\end{tcolorbox}

Of course, it is possible to create additional files or directories within this structure in order to use them in your JavaScript code.
This can e.g.\@ be useful to structure code, but also if some functions or data sets shall be used across different FaaS functions.
In any case, we suggest to utilize Node.js module semantics as shown in \Cref{fig:dividingDataAndFunctionCodeNodeJS}.

\begin{figure}
\begin{tcolorbox}[left=3mm, right=3mm, top=3mm]
  \begin{tcolorbox}[enhanced, title={\texttt{[\ldots]/exampleFunction/data.js}}, attach boxed title to bottom left, boxed title style={sharp corners}]
  \begin{minted}{js}
  const prices = {
    umbrella: 20,
    coat: 60,
    flowerPot: 5
  }

  module.exports = { prices }
  \end{minted}
  \end{tcolorbox}

  \begin{tcolorbox}[enhanced, title=\texttt{{[\ldots]/exampleFunction/index.js}}, attach boxed title to bottom left, boxed title style={sharp corners}]
  \begin{minted}{js}
  const { prices } = require('./data')
  const lib = require('@faastermetrics/lib')

  module.exports = lib.serverless.rpcHandler(async _ => {
    const totalCost = Object.values(prices).reduce((a,b) => a+b)
    return { totalCost }
  })
  \end{minted}
  \end{tcolorbox}

\end{tcolorbox}
\caption{Using Node.js module semantics to split some data and a function using it into separate files.}%
\label{fig:dividingDataAndFunctionCodeNodeJS}
\end{figure}

\subsection{Function Wrapper}
koa.js (footnote)

\subsubsection{`rpcHandler'}%
\label{ssub:rpcHandler}
Main function handler, used nearly everywhere, true to FaaS paradigm
What are event, ctx

Router
Sometimes routes needed (e.g.\@ in our Webshop frontend)
(Ask Emily for route fix explanation)

\subsection{Database Access}
Redis DB for experiment
Hosted on AWS EC2

\subsection{Calling Other FaaS Functions}
Assumption: unique name


\subsection{Custom Log Output}

\subsection{Endpoint /call and JSON object passing}


\end{document}

